{"version":3,"sources":["PathfindingVisualizer/Node/Node.js","algorithms/dijkstra.js","algorithms/astar.js","PathfindingVisualizer/PathfindingVisualizer.js","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","row","col","isStart","isFinish","isWall","onMouseDown","onMouseEnter","onMouseUp","extraClassName","weight","heuristic","id","className","Component","dijkstra","grid","startNode","finishNode","distance","visitedNodes","unvisitedNodes","nodes","node","push","filter","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","node1","node2","unvisitedNeighborNodes","getNeighbors","neighborNode","newDistance","previousNode","neighbors","neighbor","getPath","path","currentNode","reverse","row1","col1","row2","col2","Math","sqrt","pow","PathfindingVisualizer","state","mouseIsPressed","initializeGrid","setState","newGrid","getNewGridWithWallToggled","i","setTimeout","document","getElementById","animateShortestPath","refreshWall","nodeClassName","refreshGrid","visited","animateDijkstra","frontier","previous","includes","aStar","animateAStar","onClick","visualizeDijkstra","visualizeAStar","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","newNode","createNode","slice","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.483a86e5.chunk.js","sourcesContent":["import React, {Component} from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      row,\n      col,\n      isStart,\n      isFinish,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      weight,\n      heuristic,\n      } = this.props;\n    const extraClassName = isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></div>\n    );\n  }\n}\n","// Implement the Dijkstra's algorithm here\n\n\n// Dijkstra's algorithm implementation\n// Input: grid, startNode, finishNode\n// Return: If we found the node, then return the path;\n//         if we are unable to reach the nodes, ie. there is a wall, then we stop\nexport function dijkstra(grid, startNode, finishNode) {\n\n  // At the beginning, the distance of the startNode is 0 by default\n  startNode.distance = 0;\n  // visitedNodes array stores all the nodes that are visited\n  const visitedNodes = [];\n  //\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (unvisitedNodes.length !== 0) {\n    sortNodesByDistance(unvisitedNodes);\n\n    const closestNode = unvisitedNodes.shift();\n    // If the closestNode is infinity, that means we are unable to reach the target\n    if (closestNode.distance === Infinity) return visitedNodes;\n\n    // If the closestNode is not Infinity, that means we are able to reach it\n    else {\n      closestNode.isVisited = true;\n      visitedNodes.push(closestNode);\n\n      updateUnvisitedNeighbors(closestNode, grid);\n      if (closestNode === finishNode) return visitedNodes;\n    }\n  }\n}\n\n\n\n\n// Sort all the unvisited adjacent nodes, don't need to return anything\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort(function(node1, node2) {return node1.distance - node2.distance});\n}\n\n\n\n// take current node and the grid, update the unvisited node and update\n// the distance, return nothing\nexport function updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighborNodes = getNeighbors(node, grid);\n\n  for (const neighborNode of unvisitedNeighborNodes) {\n    const newDistance = neighborNode.weight + node.distance;\n    if (newDistance < neighborNode.distance) {\n      neighborNode.distance = newDistance;\n      neighborNode.previousNode = node;\n    }\n  }\n}\n\n\n// take current node, and return it's unvisited neighbors\nexport function getNeighbors(node, grid) {\n  const neighbors = [];\n  const {row, col} = node;\n\n  // Up:\n  if (row - 1 >= 0) neighbors.push(grid[row-1][col]);\n  // Down:\n  if (row + 1 < grid.length) neighbors.push(grid[row+1][col]);\n  // Left:\n  if (col - 1 >= 0) neighbors.push(grid[row][col-1]);\n  // Right:\n  if (col + 1 < grid[0].length) neighbors.push(grid[row][col+1]);\n\n  // We only want to consider the unvisited neighbors\n  return neighbors.filter(neighbor => neighbor.isVisited === false, neighbor => neighbor.isWall === false);\n}\n\n\n// Return all the nodes (a list), and filter out all the wall nodes\nexport function getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes.filter(node => node.isWall === false);\n}\n\n\n\nexport function getPath(finishNode) {\n  const path = [];\n\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    path.push(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return path.reverse();\n}\n","// Implement the A Star Algorithm\nimport {getAllNodes, getPath, getNeighbors} from './dijkstra';\n\n\nexport function aStar(grid, startNode, finishNode) {\n  startNode.distance = 0;\n  startNode.heuristic = heuristic(startNode, finishNode);\n  const visitedNodes = [];\n\n  const frontier = [startNode];\n\n  while (frontier.length !== 0) {\n\n    sortNodesByCost(frontier);\n\n    const previous = frontier.shift();\n    // Might want to rewrite the getNeighbors() function to make sure it\n    // works when adding 'weight' property\n    const neighbors = getNeighbors(previous, grid);\n\n    for (const neighbor of neighbors) {\n      if (neighbor.isWall === false) {\n        neighbor.distance = previous.distance + neighbor.weight;\n        neighbor.heuristic = heuristic(neighbor, finishNode);\n        neighbor.previousNode = previous;\n        if (!frontier.includes(neighbor)) {\n          frontier.push(neighbor);\n        }\n      }\n    }\n\n    // If the closestNode is infinity, that means we are unable to reach the target\n    if (previous.distance === Infinity) {\n      return visitedNodes;\n    }\n\n    // If the closestNode is not Infinity, that means we are able to reach it\n    else {\n      previous.isVisited = true;\n      visitedNodes.push(previous);\n      if (previous === finishNode) {\n        return visitedNodes;\n      }\n    }\n  }\n  // If we traverse all the nodes but we're still unable to find the target, return anyway.\n  return visitedNodes;\n}\n\n\n\n// calcuate the heuristic of a given point,\n// in this case, it's the Euclidean distance\n// between this node and the finish node\nfunction heuristic(node, finishNode) {\n  const row1 = node.row;\n  const col1 = node.col;\n  const row2 = finishNode.row;\n  const col2 = finishNode.col;\n  const euclideanDistance = Math.sqrt((Math.pow(row1-row2,2) +  Math.pow(col1-col2,2)));\n  return euclideanDistance;\n}\n\n\nfunction sortNodesByCost(unvisitedNodes) {\n  unvisitedNodes.sort(function(node1, node2) {return (node1.heuristic+node1.distance) - (node2.heuristic+node2.distance)});\n}\n","import React, {Component} from 'react';\nimport Node from  './Node/Node';\n\nimport './PathfindingVisualizer.css';\nimport {dijkstra, getPath} from '../algorithms/dijkstra';\nimport {aStar} from '../algorithms/astar';\n\nconst DEFAULT_START_ROW = 4;\nconst DEFAULT_START_COL = 4;\nconst DEFAULT_TARGET_ROW = 15;\nconst DEFAULT_TARGET_COL = 30;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n    };\n  }\n\n  // Naively create a 20X50 grid on the screen\n  componentDidMount() {\n    const grid = initializeGrid();\n    this.setState({grid});\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({grid: newGrid, mouseIsPressed: true});\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({grid: newGrid});\n  }\n\n  handleMouseUp() {\n    this.setState({mouseIsPressed: false});\n  }\n\n  animateDijkstra(visitedNodes, path) {\n    for (let i = 1; i < visitedNodes.length; i++) {\n      // If we didn't reach the end of the list,\n      // then we keep rendering the visted nodes\n      if (i !== visitedNodes.length-1) {\n        setTimeout(() => {\n          const node = visitedNodes[i];\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n        }, 10 * i);\n      }\n\n      // If we reach the end of the array, then we'll also animate the shortest path\n      else {\n        setTimeout(() => {\n          this.animateShortestPath(path)} , 10 * i);\n      }\n    }\n  }\n\n  animateAStar(visitedNodes, path) {\n    for (let i = 1; i < visitedNodes.length; i++) {\n      // If we didn't reach the end of the list,\n      // then we keep rendering the visted nodes\n      if (i !== visitedNodes.length-1) {\n        setTimeout(() => {\n          const node = visitedNodes[i];\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n        }, 10 * i);\n      }\n\n      // If we reach the end of the array, then we'll also animate the shortest path\n      else {\n        setTimeout(() => {\n          this.animateShortestPath(path)} , 10 * i);\n      }\n    }\n  }\n\n  animateShortestPath(path) {\n    for (let i = 1; i < path.length-1; i++) {\n      setTimeout(() => {\n        const node = path[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className='node node-shortest-path';}, 50*i);\n    }\n  }\n\n  refreshGrid(refreshWall) {\n    const {grid} = this.state;\n    for (const row of grid) {\n      for (const node of row) {\n        node.distance = Infinity;\n        node.isVisited = false;\n        node.previousNode = null;\n        node.weight = 1;\n        node.heuristic = 0;\n        const nodeClassName = document.getElementById(`node-${node.row}-${node.col}`).className;\n        if (nodeClassName === 'node node-shortest-path' || nodeClassName === 'node node-visited') {\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-unvisited';\n        }\n\n        if (refreshWall === true) {\n          node.isWall = false;\n          if (nodeClassName === 'node node-wall') {\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-unvisited';\n          }\n        }\n      }\n    }\n  }\n\n  visualizeDijkstra() {\n\n    const {grid} = this.state;\n    this.refreshGrid(false);\n    const startNode = grid[DEFAULT_START_ROW][DEFAULT_START_COL];\n    const finishNode = grid[DEFAULT_TARGET_ROW][DEFAULT_TARGET_COL];\n\n    const visited = dijkstra(grid, startNode, finishNode);\n    const path = getPath(finishNode);\n    this.animateDijkstra(visited, path);\n  }\n\n  visualizeAStar() {\n\n    const {grid} = this.state;\n    this.refreshGrid(false);\n    const startNode = grid[DEFAULT_START_ROW][DEFAULT_START_COL];\n    const finishNode = grid[DEFAULT_TARGET_ROW][DEFAULT_TARGET_COL];\n    const visited = aStar(grid, startNode, finishNode);\n    const path = getPath(finishNode);\n    this.animateAStar(visited, path);\n  }\n\n  render() {\n    const {grid, mouseIsPressed} = this.state;\n\n\n    return (\n      <>\n        <button onClick={() => this.visualizeDijkstra()}>\n          Visualize Dijkstra's Algorithm\n        </button>\n        <button onClick={() => this.visualizeAStar()}>\n          Visualize A Star Algorithm\n        </button>\n        <button onClick={() => this.refreshGrid(true)}>\n          Reset Grid\n        </button>\n      <div className=\"grid\">\n        {grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx}>\n              {row.map((node, nodeIdx) => {\n                const {row, col, isStart, isFinish, isWall} = node;\n                return (\n                  <Node\n                    key={nodeIdx}\n                    row={row}\n                    col={col}\n                    isStart={isStart}\n                    isFinish={isFinish}\n                    isWall={isWall}\n                    mouseIsPressed={mouseIsPressed}\n                    onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                    onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                    onMouseUp={() => this.handleMouseUp()}></Node>\n                );\n              })}\n              </div>\n          );\n        })}\n      </div>\n    </>\n    );\n  }\n}\n\n// A me thod to create the graph\nconst initializeGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      let newNode = createNode(row,col);\n      currentRow.push(newNode);\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\n\n\n// A method to create the node\n// we need other properties for our algorithm\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === DEFAULT_START_ROW && col === DEFAULT_START_COL,\n    isFinish: row === DEFAULT_TARGET_ROW && col === DEFAULT_TARGET_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    weight: 1,\n    heuristic: 0,\n  };\n};\n\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}