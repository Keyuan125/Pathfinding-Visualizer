{"version":3,"sources":["PathfindingVisualizer/Node/Node.js","algorithms/dijkstra.js","PathfindingVisualizer/PathfindingVisualizer.js","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","row","col","isStart","isFinish","isWall","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","distance","visitedNodes","unvisitedNodes","nodes","node","push","filter","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","node1","node2","unvisitedNeighborNodes","neighbors","neighbor","getNeighbors","neighborNode","newDistance","weight","previousNode","PathfindingVisualizer","state","mouseIsPressed","initializeGrid","setState","console","log","newGrid","getNewGridWithWallToggled","path","i","setTimeout","document","getElementById","animateShortestPath","visited","currentNode","reverse","getPath","animateDijkstra","onClick","visualizeDijkstra","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","newNode","createNode","slice","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.7aa9cc55.chunk.js","sourcesContent":["import React, {Component} from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      row,\n      col,\n      isStart,\n      isFinish,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      } = this.props;\n    const extraClassName = isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></div>\n    );\n  }\n}\n","// Implement the Dijkstra's algorithm here\n\n\n// Dijkstra's algorithm implementation\n// Input: grid, startNode, finishNode\n// Return: If we found the node, then return the path;\n//         if we are unable to reach the nodes, ie. there is a wall, then we stop\nexport function dijkstra(grid, startNode, finishNode) {\n\n  // At the beginning, the distance of the startNode is 0 by default\n  startNode.distance = 0;\n  // visitedNodes array stores all the nodes that are visited\n  const visitedNodes = [];\n  //\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (unvisitedNodes.length !== 0) {\n    sortNodesByDistance(unvisitedNodes);\n\n    const closestNode = unvisitedNodes.shift();\n    // If the closestNode is infinity, that means we are unable to reach the target\n    if (closestNode.distance === Infinity) return visitedNodes;\n\n    // If the closestNode is not Infinity, that means we are able to reach it\n    else {\n      closestNode.isVisited = true;\n      visitedNodes.push(closestNode);\n\n      updateUnvisitedNeighbors(closestNode, grid);\n      if (closestNode === finishNode) return visitedNodes;\n    }\n  }\n}\n\n\n\n\n// Sort all the unvisited adjacent nodes, don't need to return anything\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort(function(node1, node2) {return node1.distance - node2.distance});\n}\n\n\n\n// take current node and the grid, update the unvisited node and update\n// the distance, return nothing\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighborNodes = getNeighbors(node, grid);\n\n  for (const neighborNode of unvisitedNeighborNodes) {\n    const newDistance = neighborNode.weight + node.distance;\n    if (newDistance < neighborNode.distance) {\n      neighborNode.distance = newDistance;\n      neighborNode.previousNode = node;\n    }\n  }\n}\n\n\n// take current node, and return it's unvisited neighbors\nfunction getNeighbors(node, grid) {\n  const neighbors = [];\n  const {row, col} = node;\n\n  // Up:\n  if (row - 1 >= 0) neighbors.push(grid[row-1][col]);\n  // Down:\n  if (row + 1 < grid.length) neighbors.push(grid[row+1][col]);\n  // Left:\n  if (col - 1 >= 0) neighbors.push(grid[row][col-1]);\n  // Right:\n  if (col + 1 < grid[0].length) neighbors.push(grid[row][col+1]);\n\n  // We only want to consider the unvisited neighbors\n  return neighbors.filter(neighbor => neighbor.isVisited === false);\n}\n\n\n// Return all the nodes (a list), and filter out all the wall nodes\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes.filter(node => node.isWall === false);\n}\n\n\n\nexport function getPath(finishNode) {\n  const path = [];\n\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    path.push(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return path.reverse();\n}\n","import React, {Component} from 'react';\nimport Node from  './Node/Node';\n\nimport './PathfindingVisualizer.css';\nimport {dijkstra, getPath} from '../algorithms/dijkstra';\n\nconst DEFAULT_START_ROW = 5;\nconst DEFAULT_START_COL = 10;\nconst DEFAULT_TARGET_ROW = 4;\nconst DEFAULT_TARGET_COL = 36;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n    };\n  }\n\n  // Naively create a 20X50 grid on the screen\n  componentDidMount() {\n    const grid = initializeGrid();\n    this.setState({grid});\n  }\n\n  handleMouseDown(row, col) {\n    console.log(\"Mouse Down\");\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({grid: newGrid, mouseIsPressed: true});\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({grid: newGrid});\n  }\n\n  handleMouseUp() {\n    this.setState({mouseIsPressed: false});\n  }\n\n  animateDijkstra(visitedNodes, path) {\n    for (let i = 1; i < visitedNodes.length; i++) {\n      // If we didn't reach the end of the list,\n      // then we keep rendering the visted nodes\n      if (i !== visitedNodes.length-1) {\n        setTimeout(() => {\n          const node = visitedNodes[i];\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n        }, 10 * i);\n      }\n\n      // If we reach the end of the array, then we'll also animate the shortest path\n      else {\n        setTimeout(() => {\n          this.animateShortestPath(path)} , 10 * i);\n      }\n    }\n  }\n\n  animateShortestPath(path) {\n    for (let i = 1; i < path.length-1; i++) {\n      setTimeout(() => {\n        const node = path[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className='node node-shortest-path';}, 50*i);\n    }\n  }\n\n\n  visualizeDijkstra() {\n    const {grid} = this.state;\n\n    const startNode = grid[DEFAULT_START_ROW][DEFAULT_START_COL];\n    const finishNode = grid[DEFAULT_TARGET_ROW][DEFAULT_TARGET_COL];\n\n    const visited = dijkstra(grid, startNode, finishNode);\n    const path = getPath(finishNode);\n    this.animateDijkstra(visited, path);\n  }\n\n\n  render() {\n    const {grid, mouseIsPressed} = this.state;\n\n\n    return (\n      <>\n        <button onClick={() => this.visualizeDijkstra()}>\n          Visualize Dijkstra's Algorithm\n        </button>\n      <div className=\"grid\">\n        {grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx}>\n              {row.map((node, nodeIdx) => {\n                const {row, col, isStart, isFinish, isWall} = node;\n                return (\n                  <Node\n                    key={nodeIdx}\n                    row={row}\n                    col={col}\n                    isStart={isStart}\n                    isFinish={isFinish}\n                    isWall={isWall}\n                    mouseIsPressed={mouseIsPressed}\n                    onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                    onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                    onMouseUp={() => this.handleMouseUp()}></Node>\n                );\n              })}\n              </div>\n          );\n        })}\n      </div>\n    </>\n    );\n  }\n}\n\n// A me thod to create the graph\nconst initializeGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      let newNode = createNode(row,col);\n      currentRow.push(newNode);\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\n\n\n// A method to create the node\n// we need other properties for our algorithm\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === DEFAULT_START_ROW && col === DEFAULT_START_COL,\n    isFinish: row === DEFAULT_TARGET_ROW && col === DEFAULT_TARGET_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    weight: 1,\n  };\n};\n\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}