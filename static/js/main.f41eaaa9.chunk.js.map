{"version":3,"sources":["PathfindingVisualizer/Node/Node.js","algorithms/dijkstra.js","PathfindingVisualizer/PathfindingVisualizer.js","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","row","col","isStart","isFinish","isWall","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","distance","visitedNodes","unvisitedNodes","nodes","node","push","filter","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","node1","node2","unvisitedNeighborNodes","neighbors","neighbor","getNeighbors","neighborNode","newDistance","weight","previousNode","PathfindingVisualizer","state","mouseIsPressed","initializeGrid","setState","path","i","setTimeout","document","getElementById","animateShortestPath","console","log","visited","currentNode","reverse","getPath","animateDijkstra","onClick","visualizeDijkstra","map","rowIdx","nodeIdx","currentRow","newNode","createNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.f41eaaa9.chunk.js","sourcesContent":["import React, {Component} from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {row, col, isStart, isFinish, isWall} = this.props;\n    const extraClassName = isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}></div>\n    );\n  }\n}\n","// Implement the Dijkstra's algorithm here\n\n\n// Dijkstra's algorithm implementation\n// Input: grid, startNode, finishNode\n// Return: If we found the node, then return the path;\n//         if we are unable to reach the nodes, ie. there is a wall, then we stop\nexport function dijkstra(grid, startNode, finishNode) {\n\n  // At the beginning, the distance of the startNode is 0 by default\n  startNode.distance = 0;\n  // visitedNodes array stores all the nodes that are visited\n  const visitedNodes = [];\n  //\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (unvisitedNodes.length !== 0) {\n    sortNodesByDistance(unvisitedNodes);\n\n    const closestNode = unvisitedNodes.shift();\n    // If the closestNode is infinity, that means we are unable to reach the target\n    if (closestNode.distance === Infinity) return visitedNodes;\n\n    // If the closestNode is not Infinity, that means we are able to reach it\n    else {\n      closestNode.isVisited = true;\n      visitedNodes.push(closestNode);\n\n      updateUnvisitedNeighbors(closestNode, grid);\n      if (closestNode === finishNode) return visitedNodes;\n    }\n  }\n}\n\n\n\n\n// Sort all the unvisited adjacent nodes, don't need to return anything\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort(function(node1, node2) {return node1.distance - node2.distance});\n}\n\n\n\n// take current node and the grid, update the unvisited node and update\n// the distance, return nothing\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighborNodes = getNeighbors(node, grid);\n\n  for (const neighborNode of unvisitedNeighborNodes) {\n    const newDistance = neighborNode.weight + node.distance;\n    if (newDistance < neighborNode.distance) {\n      neighborNode.distance = newDistance;\n      neighborNode.previousNode = node;\n    }\n  }\n}\n\n\n// take current node, and return it's unvisited neighbors\nfunction getNeighbors(node, grid) {\n  const neighbors = [];\n  const {row, col} = node;\n\n  // Up:\n  if (row - 1 >= 0) neighbors.push(grid[row-1][col]);\n  // Down:\n  if (row + 1 < grid.length) neighbors.push(grid[row+1][col]);\n  // Left:\n  if (col - 1 >= 0) neighbors.push(grid[row][col-1]);\n  // Right:\n  if (col + 1 < grid[0].length) neighbors.push(grid[row][col+1]);\n\n  // We only want to consider the unvisited neighbors\n  return neighbors.filter(neighbor => neighbor.isVisited === false);\n}\n\n\n// Return all the nodes (a list), and filter out all the wall nodes\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes.filter(node => node.isWall === false);\n}\n\n\n\nexport function getPath(finishNode) {\n  const path = [];\n\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    path.push(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return path.reverse();\n}\n","import React, {Component} from 'react';\nimport Node from  './Node/Node';\n\nimport './PathfindingVisualizer.css';\nimport {dijkstra, getPath} from '../algorithms/dijkstra';\n\nconst DEFAULT_START_ROW = 5;\nconst DEFAULT_START_COL = 10;\nconst DEFAULT_TARGET_ROW = 4;\nconst DEFAULT_TARGET_COL = 36;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n    };\n  }\n\n  // Naively create a 20X50 grid on the screen\n  componentDidMount() {\n    const grid = initializeGrid();\n\n    this.setState({grid});\n  }\n\n\n  animateDijkstra(visitedNodes, path) {\n    for (let i = 1; i < visitedNodes.length; i++) {\n      // If we didn't reach the end of the list,\n      // then we keep rendering the visted nodes\n      if (i !== visitedNodes.length-1) {\n        setTimeout(() => {\n          const node = visitedNodes[i];\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n        }, 10 * i);\n      }\n\n      // If we reach the end of the array, then we'll also animate the shortest path\n      else {\n        setTimeout(() => {\n          this.animateShortestPath(path)} , 10 * i);\n      }\n    }\n  }\n\n  animateShortestPath(path) {\n    for (let i = 1; i < path.length-1; i++) {\n      console.log(path[i]);\n      setTimeout(() => {\n        const node = path[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className='node node-shortest-path';}, 50*i);\n    }\n  }\n\n\n  visualizeDijkstra() {\n    const {grid} = this.state;\n\n    const startNode = grid[DEFAULT_START_ROW][DEFAULT_START_COL];\n    const finishNode = grid[DEFAULT_TARGET_ROW][DEFAULT_TARGET_COL];\n\n    const visited = dijkstra(grid, startNode, finishNode);\n    const path = getPath(finishNode);\n    this.animateDijkstra(visited, path);\n  }\n\n\n  render() {\n    const {grid, mouseIsPressed} = this.state;\n\n\n    return (\n      <>\n        <button onClick={() => this.visualizeDijkstra()}>\n          Visualize Dijkstra's Algorithm\n        </button>\n      <div className=\"grid\">\n        {grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx}>\n              {row.map((node, nodeIdx) => {\n                const {row, col, isStart, isFinish, isWall} = node;\n                return (\n                  <Node\n                    key={nodeIdx}\n                    row={row}\n                    col={col}\n                    isStart={isStart}\n                    isFinish={isFinish}\n                    isWall={isWall}></Node>\n                );\n              })}\n              </div>\n          );\n        })}\n      </div>\n    </>\n    );\n  }\n}\n\n// A me thod to create the graph\nconst initializeGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      let newNode = createNode(row,col);\n      if (col > 12 && col < 26 && row < 19) newNode.isWall = true;\n      currentRow.push(newNode);\n\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\n\n\n// A method to create the node\n// we need other properties for our algorithm\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === DEFAULT_START_ROW && col === DEFAULT_START_COL,\n    isFinish: row === DEFAULT_TARGET_ROW && col === DEFAULT_TARGET_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    weight: 1,\n  };\n};\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <PathfindingVisualizer />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}